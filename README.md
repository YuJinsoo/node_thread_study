# node_thread_study

## 이벤트 루프
- Node.js가 여러 비동기 작업을 관리하기 위한 구현체
- `console.log("Hello World")`와 같은 동기 작업이 아니라`file.readFile('test.txt', callback)`과 같은 비동기 작업들을 모아서 관리하고 순서대로 실행할 수 있게 해주는 도구이며 위와 같이 구성되어있다.

### 이벤트 루프 특징
- 6개의 페이즈로 구성
- 다음 페이즈로 넘어가는 것을 틱 이라고 함.
- 각 페이즈는 자신만의 큐를 관리
- 순서대로 페이즈를 방문하면서 큐에 쌓인 작업을 하나씩 실행
- 페이즈의 큐에 담긴 작업을 모두 실행하거나 시스템의 실행 한도에 다다르면 Node.js는 다음 페이즈로 넘어간다.
- 이벤트 루프가 살아있는 한 Node.js는 이벤트 루프를 반복
- 쌓인 작업을 처리하던 중 이전 페이즈에서 실행했던 작업의 콜백이나 커널이 스케줄링한 새로운 작업이 큐에 추가될 수 있다.
- Node.js가 큐에 계속 추가되는 작업을 처리하느라 다음 페이즈로 넘어가지 못할 수 있다. 단, 페이즈는 시스템의 실행 한도의 영향을 받으므로 Node.js가 한 페이즈에 영원히 갇히는 일은 없다.

### Nodejs 실행 순서
1. Node.js는 코드를 실행하기 전에 우선 이벤트 루프를 생성한다.
2. Node.js는 이벤트 루프 바깥에서 코드를 처음부터 끝까지 실행한다.
3. 이벤트 루프가 살아있는지 확인하고 진입하거나 Exit Callbacks을 실행하고 프로그램을 종료한다.
4. 이벤트 루프에 진입하면 페이즈를 차례대로 돌면서 실행할 수 있는 작업을 실행한다.
5. 매 반복마다 이벤트 루프가 살아있는지 확인하고 죽었다면 Exit Callbacks을 실행하고 프로그램을 종료한다.

### 이벤트 루프 페이즈
- Timer Phase
- Pending Callbacks Phase
- Idle, Prepare Phase
- Poll Phase
- Check Phase
- Close Callbacks Phase


### 이벤트 루프 페이즈 특징
https://velog.io/@haron/Node.js%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%8B%B1%EA%B8%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EB%A1%9C-%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%9E%91%EC%97%85%EC%9D%84-%EC%A7%80%EC%9B%90%ED%95%98%EB%8A%94%EA%B1%B8%EA%B9%8C

## libuv 라이브러리
- C++로 작성된 Node.js가 사용하는 비동기 I/O 라이브러리
- 이는 사실 운영체제의 커널을 추상화한 Wrapping 라이브러리로 커널이 어떤 비동기 API를 지원하는지 알고있다.

- 작동과정
    1. libuv는 운영체제의 커널을 추상화해서 비동기 API를 지원한다.
    2. libuv는 커널이 어떤 비동기 API를 지원하고 있는지 알고 있다.
    3. 만약 커널이 지원하는 비동기 작업을 libuv에게 요청하면 libuv는 대신 커널에게 이 작업을 비동기적으로 요청해준다.
    4. 만약 커널이 지원하지 않는 비동기 작업을 libuv에게 요청하면 livuv는 내부에 가지고있는 스레드 풀에게 이 작업을 요청해준다.


## Nodejs에서 사용하는 thread 관리 라이브러리

## Nodejs에서 사용하는 process 관리 라이브러리